#' @title Data scrubbing
#' @description If the unit of BG measurement is mmol/L, this function, performs
#'   the following steps:
#' \itemize{
#'  \item{"<0.6" or ">33.3" reset to 0.6 and 33.3 respectively,}
#'  \item{"<" or ">" for middle values, decrement or increment by 0.1,}
#'  \item{"Low/lo" or "H/High" reset to limiting values 0.6 and 33.3,}
#'  \item{take the average BG at the same timing for particular patient, this
#'    might be system error,}
#' }
#' and finally reports affected proportions of readings.
#' @param dat A \emph{data.frame} that at least have the following key variables:
#' \itemize{
#'  \item{RESULT} a character or numeric column for Blood Glucose readings;
#'  \item{RESULT.DATE} a date and time column of classes \dQuote{POSIXlt} and
#'    \dQuote{POSIXct} (can be generated by \code{\link{GenGluM}});
#'  \item{ADMISSION.ID} a character or numeric column for the ID of each
#'    hospital stay;
#'  \item{LOCATION} a character column for the ward of each hospital stay.
#' }
#' @param unitVal The unit indicator, 1 for mmol/L, 2 for md/dL.
#' @return The function will return a list of three elements. The first element
#'   will be the data after data scrubbing. The second element will be a vector
#'   of counts for the situations described in the first three steps taken to
#'   clean the data. The last element will report the data containing repeated
#'   measurements.
#' @examples
#' # Use a part of the example data for illustration:
#' data("gluDat")
#' gluDat <- gluDat[sort.list(gluDat$ADMISSION.ID), ]
#' dat <- gluDat[1:20, ]
#' # First format RESULT.DATE column in dat:
#' dat <- FormatDate(dat = dat, yy = 2016, mm = 7)
#' # Then distort some of the entries in dat for illustrative purpose:
#' dat$RESULT.DATE[2] <- dat$RESULT.DATE[1] # Make two timings identical for this stay
#' dat$RESULT[c(3, 8, 12, 15, 20)] <- c("<9.4", ">33.3", "c6.4", "lo", "<0.6")
#' # Make entry 12 unrecognisable
#' dat
#' # Now scrub dat:
#' DataScrubbing(dat = dat, unitVal = 1)
#' @author Ying Chen
#' @export
DataScrubbing <- function(dat, unitVal){
  if(unitVal == 1){
    dat$RESULT <- gsub(" ","",dat$RESULT)

    idminl <- which(grepl("<0.6", dat$RESULT))

    if(length(idminl) > 0){
      dat[idminl, ]$RESULT = "0.6"
    }


    idmaxl <- which(grepl(">33.3", dat$RESULT))

    if( length(idmaxl) > 0){
      dat[idmaxl, ]$RESULT = "33.3"
    }


    idlt <- which(grepl("<", dat$RESULT))
    if(length(idlt) > 0){
      dat[idlt, ]$RESULT = as.character(as.numeric(gsub("<","", dat[idlt, ]$RESULT)) - 0.1)
    }


    idgt <- which(grepl(">", dat$RESULT))
    if(length(idgt) > 0){
      dat[idgt, ]$RESULT = as.character(as.numeric(gsub(">","", dat[idgt, ]$RESULT)) + 0.1)
    }

    # detect non-numerical values, will be set limiting values
    idlo <- which(grepl("l",tolower(dat$RESULT)))
    if(length(idlo) > 0){
      dat[idlo, ]$RESULT = 0.6
    }

    idhi <- which(grepl("h",tolower(dat$RESULT)))
    if(length(idhi) > 0){
      dat[idhi, ]$RESULT = 33.3
    }

    # numericalize the readings
    dat$RESULT = as.numeric(dat$RESULT)
    # remove those with NAs
    if(length(which(is.na(dat$RESULT))) > 0){
      warning(paste0("We removed ", length(which(is.na(dat$RESULT))), " (",round(length(which(is.na(dat$RESULT)))/nrow(dat)*100,2),"% ) "," non-numerical values other than involing < and > signs."))
      dat = dat[!is.na(dat$RESULT), ]

    }
  }else{
   idminl <- NULL
   idmaxl <- NULL
   idlt <- NULL
   idgt <- NULL
   idlo <- NULL
   idhi <- NULL
  }

  l <- c(minLim = length(idminl), maxLim = length(idmaxl), ltSign = length(idlt), gtSign = length(idgt), lo = length(idlo), hi = length(idhi), total = nrow(dat))

  duplex <- unique(dat[, list(count = length(unique(RESULT)), Dif = diff(unique(RESULT))), by = list(LOCATION, ADMISSION.ID, RESULT.DATE)])
  d <- list(c(sum(duplex$count > 1), nrow(duplex)), duplex$Dif)
  dat[, RESULT.MEAN := RESULT, by = list(LOCATION, ADMISSION.ID, RESULT.DATE)] # Generate RESULT.MEAN depends on duplicated measurements
  dat = unique(dat)
  out <- list(dat, l, d)

  names(out) <- c("dat","ProbValues", "Duplicates")
  return(out)
}
